use std::collections::{HashMap, VecDeque};
use std::sync::Arc;
use tokio::sync::{mpsc, Mutex};

use maelstrom_rust_node::{
    message::{Message},
    process_message_line,
    storage::Storage,
};

use serde::{Deserialize, Serialize};
use serde_json::Value;

#[derive(Serialize, Deserialize, Debug)]
pub struct ReplyMessage {
    pub src: String,
    pub dest: String,
    pub body: Value,
}

pub struct TestNode {
    #[allow(dead_code)]
    pub id: String,
    pub storage: Arc<Mutex<Storage>>,
    #[allow(dead_code)]
    pub tx: mpsc::Sender<String>,
    #[allow(dead_code)]
    pub rx: mpsc::Receiver<String>,
}

impl TestNode {
    pub async fn new(id: String, _workload: String) -> Self {
        let storage = Storage::new();
        let storage_arc = Arc::new(Mutex::new(storage));
        storage_arc.lock().await.set_id(&id).await;

        let (tx, rx) = mpsc::channel(100);

        Self {
            id,
            storage: storage_arc,
            tx,
            rx,
        }
    }
}

pub struct TestNetwork {
    pub nodes: HashMap<String, TestNode>,
    message_queue: VecDeque<Message>,
    received_replies: VecDeque<ReplyMessage>,
}

impl TestNetwork {
    pub fn new() -> Self {
        Self {
            nodes: HashMap::new(),
            message_queue: VecDeque::new(),
            received_replies: VecDeque::new(),
        }
    }

    pub async fn add_node(&mut self, id: String, workload: String) {
        let node = TestNode::new(id.clone(), workload).await;
        self.nodes.insert(id, node);
    }

    pub fn send_message(&mut self, msg: Message) {
        self.message_queue.push_back(msg);
    }

    pub async fn tick(&mut self) -> bool {
        if let Some(msg) = self.message_queue.pop_front() {
            // If the message is a reply to the client, add it to received_replies
            if msg.dest == "client" {
                let reply_msg: ReplyMessage = serde_json::from_str(&serde_json::to_string(&msg).unwrap()).unwrap();
                self.received_replies.push_back(reply_msg);
                return true; // Message processed
            }

            // Otherwise, it's a message to a managed node
            let dest_node = self.nodes.get_mut(&msg.dest).unwrap(); // This unwrap should now be safe
            let (tx, mut rx) = mpsc::channel(100);

            let msg_json = serde_json::to_string(&msg).unwrap();
            process_message_line(
                msg_json,
                &mut *dest_node.storage.lock().await,
                tx,
            )
            .await
            .unwrap();

            // Collect new messages/replies generated by the processed node
            while let Some(output_str) = rx.recv().await {
                // Try to deserialize as a Message (for requests like broadcast from node to node)
                if let Ok(new_msg) = serde_json::from_str::<Message>(&output_str) {
                    self.message_queue.push_front(new_msg);
                }
                // Try to deserialize as a ReplyMessage (for replies to the client)
                else if let Ok(reply_msg) = serde_json::from_str::<ReplyMessage>(&output_str) {
                    self.received_replies.push_back(reply_msg);
                } else {
                    panic!("Failed to deserialize message from node output: {}", output_str);
                }
            }

            true
        } else {
            false
        }
    }

    pub fn get_last_reply(&mut self) -> Option<ReplyMessage> {
        self.received_replies.pop_front()
    }

    pub fn get_node_storage(&self, node_id: &str) -> Arc<Mutex<Storage>> {
        Arc::clone(&self.nodes.get(node_id).unwrap().storage)
    }
}